repeat wait() until game:IsLoaded()
print("engovape latest loaded")
local VERSION = "ENGO-1.07"

local GuiLibrary = shared.GuiLibrary
local players = game:GetService("Players")
local lplr = players.LocalPlayer
local workspace = game:GetService("Workspace")
local lighting = game:GetService("Lighting")
local cam = workspace.CurrentCamera
local targetinfo = shared.VapeTargetInfo
local collectionservice = game:GetService("CollectionService")
local uis = game:GetService("UserInputService")
local mouse = lplr:GetMouse()
local robloxfriends = {}
local bedwars = {}
local getfunctions
local origC0 = nil
local matchState = 0
local kit = ""
local antivoidypos = 0
local scaffoldypos = 0
local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or getgenv().request or request
local queueteleport = syn and syn.queue_on_teleport or queue_on_teleport or fluxus and fluxus.queue_on_teleport
local getasset = getsynasset or getcustomasset
local movementControls = require(game:GetService("Players").LocalPlayer.PlayerScripts.PlayerModule):GetControls()


local checkpublicreponum = 0
local checkpublicrepo
checkpublicrepo = function(id)
	local suc, req = pcall(function() return requestfunc({
		Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/CustomModules/"..id..".vape",
		Method = "GET"
	}) end)
	if not suc then
		checkpublicreponum = checkpublicreponum + 1
		spawn(function()
			local textlabel = Instance.new("TextLabel")
			textlabel.Size = UDim2.new(1, 0, 0, 36)
			textlabel.Text = "Loading CustomModule Failed!, Attempts : "..checkpublicreponum
			textlabel.BackgroundTransparency = 1
			textlabel.TextStrokeTransparency = 0
			textlabel.TextSize = 30
			textlabel.Font = Enum.Font.SourceSans
			textlabel.TextColor3 = Color3.new(1, 1, 1)
			textlabel.Position = UDim2.new(0, 0, 0, -36)
			textlabel.Parent = GuiLibrary["MainGui"]
			wait(2)
			textlabel:Remove()
		end)
		wait(2)
		return checkpublicrepo(id)
	end
	if req.StatusCode == 200 then
		return req.Body
	end
	return nil
end

local publicrepo = checkpublicrepo(game.PlaceId)
if publicrepo then
	loadstring(publicrepo)()
end
GuiLibrary["RemoveObject"]("PanicOptionsButton") -- remove stupid module
-- start loading custom files.

if pcall(function() readfile("engovapeprivate/CustomModules/"..game.PlaceId..".vape") end) then
	loadstring(readfile("engovapeprivate/CustomModules/"..game.PlaceId..".vape"))()
end
--local vertextsize = game:GetService("TextService"):GetTextSize(VERSION, 25, Enum.Font.SourceSans, Vector2.new(99999, 99999))
--GuiLibrary["MainGui"].ClickGui.Version.Text = VERSION
--GuiLibrary["MainGui"].ClickGui.Version.Position = UDim2.new(1, -(vertextsize.X) - 20, 1, -25)
--GuiLibrary["MainGui"].ClickGui.Version.Version.Text = VERSION



local RenderStepTable = {}
local function BindToRenderStep(name, num, func)
	if RenderStepTable[name] == nil then
		RenderStepTable[name] = game:GetService("RunService").RenderStepped:connect(func)
	end
end
local function UnbindFromRenderStep(name)
	if RenderStepTable[name] then
		RenderStepTable[name]:Disconnect()
		RenderStepTable[name] = nil
	end
end


local function createwarning(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "assets/WarningNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
	end)
end


local function createnotification(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "assets/InfoNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	end)
end

spawn(function()
	pcall(function()
		--local place = game:GetService("MarketplaceService"):GetProductInfo(6872265039)
		--if place.Updated ~= "2021-11-01T21:16:36.6294972Z" then
			--createwarning("Bedwars has updated!", place.Updated, 10) -- fix me yes
		--end
	end)
end)

local function getcustomassetfunc(path)
	if not isfile(path) then
		spawn(function()
			local textlabel = Instance.new("TextLabel")
			textlabel.Size = UDim2.new(1, 0, 0, 36)
			textlabel.Text = "Downloading "..path
			textlabel.BackgroundTransparency = 1
			textlabel.TextStrokeTransparency = 0
			textlabel.TextSize = 30
			textlabel.Font = Enum.Font.SourceSans
			textlabel.TextColor3 = Color3.new(1, 1, 1)
			textlabel.Position = UDim2.new(0, 0, 0, -36)
			textlabel.Parent = GuiLibrary["MainGui"]
			repeat wait() until isfile(path)
			textlabel:Remove()
		end)
		local req = requestfunc({
			Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/"..path:gsub("vape/assets", "assets"),
			Method = "GET"
		})
		writefile(path, req.Body)
	end
	return getasset(path) 
end

local function getItem(itemName)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"] == itemName then
			return v5, i5
		end
	end
	return nil
end

local function getHotbarSlot(itemName)
	for i5, v5 in pairs(bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.hotbar) do
		if v5["item"] and v5["item"]["itemType"] == itemName then
			return i5 - 1
		end
	end
	return nil
end

local function getSword()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("sword") or v5["itemType"]:find("blade") then
			return v5, i5
		end
	end
	return nil
end

local function getBaguette()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("baguette") then
			return v5
		end
	end
	return nil
end

local function getwool()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("wool") or v5["itemType"]:find("grass") then
			return v5["itemType"], v5["amount"], v5["tool"]
		end
	end	
	return nil
end

local function getmineralamount(arg)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match(arg) then
			return v5["amount"]
		end
	end	
	return nil
end


local function getBed(color)
	for i,v in pairs(bedwars["BedTable"]) do
		if v and v:FindFirstChild("Covers") and v.Covers.BrickColor == color then
			return v
		end
	end
	return nil
end

local function getArmor()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("helmet") or v5["itemType"]:match("chestplate") or v5["itemType"]:match("boots") then
			return v5["itemType"]
		end
	end	
	return nil
end

local function teamsAreAlive()
	local alive = false
	for i,v in pairs(game.Teams:GetChildren()) do
		if v.Name ~= "Spectators" and v.Name ~= "Neutral" and v ~= lplr.Team and #v:GetPlayers() > 0 then
			alive = true
		end
	end
	return alive
end

local function scanforbeds()
	local blocktab = game.Workspace.Map.Blocks:GetChildren()
	bedwars["BedTable"] = {}
	for i = 1, #blocktab do
		local obj = blocktab[i]
		if obj.Name == "bed" then
			bedwars["BedTable"][#bedwars["BedTable"] + 1] = obj
			if antivoidypos == 0 then
				antivoidypos = obj.Position.Y
			end
		end
	end  
end

local function randomString()
	local randomlength = math.random(10,100)
	local array = {}

	for i = 1, randomlength do
		array[i] = string.char(math.random(32, 126))
	end

	return table.concat(array)
end

local function getremote(tab)
    for i,v in pairs(tab) do
        if v == "Client" then
            return tab[i + 1]
        end
    end
    return ""
end

local newupdate = game.Players.LocalPlayer.PlayerScripts.TS:FindFirstChild("ui") and true or false
local Flamework = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@flamework"].core.out).Flamework
        repeat task.wait() until Flamework.isInitialized
        local KnitClient = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"].knit.src).KnitClient
        local Client = require(game:GetService("ReplicatedStorage").TS.remotes).default.Client
        local InventoryUtil = require(game:GetService("ReplicatedStorage").TS.inventory["inventory-util"]).InventoryUtil

bedwars = {
	["AppController"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["game-core"].client.controllers["app-controller"]).AppController,
	["BalloonController"] = KnitClient.Controllers.BalloonController,
	["BlockController"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["block-engine"].out).BlockEngine,
	["BlockController2"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["block-engine"].out.client.placement["block-placer"]).BlockPlacer,
	["BlockTryController"] = getrenv()._G[game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["block-engine"].out.client.placement["block-placer"]],
	["BlockEngine"] = require(lplr.PlayerScripts.TS.lib["block-engine"]["client-block-engine"]).ClientBlockEngine,
	["BlockEngineClientEvents"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["block-engine"].out.client["block-engine-client-events"]).BlockEngineClientEvents,
	["BedwarsKits"] = require(game:GetService("ReplicatedStorage").TS.games.bedwars.kit["bedwars-kit-shop"]).BedwarsKitShop,
	["BlockBreaker"] = KnitClient.Controllers.BlockBreakController.blockBreaker,
	["BowTable"] = KnitClient.Controllers.ProjectileController,
	["ChestController"] = KnitClient.Controllers.ChestController,
	["ClickHold"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["game-core"].client.ui.lib.util["click-hold"]).ClickHold,
	["ClientHandler"] = Client,
	["ClientHandlerDamageBlock"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["block-engine"].out.remotes).BlockEngineRemotes.Client,
	["ClientStoreHandler"] = (newupdate and require(game.Players.LocalPlayer.PlayerScripts.TS.ui.store).ClientStore or require(lplr.PlayerScripts.TS.rodux.rodux).ClientStore),
	["ClientHandlerSyncEvents"] = require(lplr.PlayerScripts.TS["client-sync-events"]).ClientSyncEvents,
	["CombatConstant"] = require(game:GetService("ReplicatedStorage").TS.combat["combat-constant"]).CombatConstant,
	["CombatController"] = KnitClient.Controllers.CombatController,
	["ConsumeSoulRemote"] = getremote(debug.getconstants(KnitClient.Controllers.GrimReaperController.consumeSoul)),
	["ConstantManager"] = require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["game-util"].out.constant["constant-manager"]).ConstantManager,
	["CooldownController"] = KnitClient.Controllers.CooldownController,
	["damageTable"] = KnitClient.Controllers.DamageController,
	["DetonateRavenRemote"] = getremote(debug.getconstants(getmetatable(KnitClient.Controllers.RavenController).detonateRaven)),
	["DropItem"] = getmetatable(KnitClient.Controllers.ItemDropController).dropItemInHand,
	["DropItemRemote"] = getremote(debug.getconstants(getmetatable(KnitClient.Controllers.ItemDropController).dropItemInHand)),
	["EatRemote"] = getremote(debug.getconstants(debug.getproto(getmetatable(KnitClient.Controllers.ConsumeController).onEnable, 1))),
	["EquipItemRemote"] = getremote(debug.getconstants(debug.getprotos(shared.oldequipitem or require(game:GetService("ReplicatedStorage").TS.entity.entities["inventory-entity"]).InventoryEntity.equipItem)[3])),
	["FishermanTable"] = KnitClient.Controllers.FishermanController,
	["GameAnimationUtil"] = require(game:GetService("ReplicatedStorage").TS.animation["animation-util"]).GameAnimationUtil,
	["getEntityTable"] = require(game:GetService("ReplicatedStorage").TS.entity["entity-util"]).EntityUtil,
	["getIcon"] = function(item, showinv)
		local itemmeta = bedwars["getItemMetadata"](item["itemType"])
		if itemmeta and showinv then
			return itemmeta.image
		end
		return ""
	end,
	["getInventory"] = function(plr)
		local suc, result = pcall(function() return InventoryUtil.getInventory(plr) end)
		return (suc and result or {
			["items"] = {},
			["armor"] = {},
			["hand"] = nil
		})
	end,
	["getItemMetadata"] = require(game:GetService("ReplicatedStorage").TS.item["item-meta"]).getItemMeta,
	["GrimReaperController"] = KnitClient.Controllers.GrimReaperController,
	["ItemTable"] = debug.getupvalue(require(game:GetService("ReplicatedStorage").TS.item["item-meta"]).getItemMeta, 1),
	["KnockbackTable"] = debug.getupvalue(require(game:GetService("ReplicatedStorage").TS.damage["knockback-util"]).KnockbackUtil.calculateKnockbackVelocity, 1),
	["KnockbackTable2"] = require(game:GetService("ReplicatedStorage").TS.damage["knockback-util"]).KnockbackUtil,
	["LobbyClientEvents"] = (newupdate and require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"].lobby.client.events).LobbyClientEvents),
	["MissileController"] = KnitClient.Controllers.GuidedProjectileController,
	["PickupRemote"] = getremote(debug.getconstants(getmetatable(KnitClient.Controllers.ItemDropController).checkForPickup)),
	["PlayerUtil"] = require(game:GetService("ReplicatedStorage").TS.player["player-util"]).GamePlayerUtil,
	["prepareHashing"] = require(game:GetService("ReplicatedStorage").TS["remote-hash"]["remote-hash-util"]).RemoteHashUtil.prepareHashVector3,
	["RavenTable"] = KnitClient.Controllers.RavenController,
	["RuntimeLib"] = require(game:GetService("ReplicatedStorage")["rbxts_include"].RuntimeLib),
	["ShieldRemote"] = getremote(debug.getconstants(debug.getprotos(getmetatable(KnitClient.Controllers.ShieldController).raiseShield)[1])),
	["Shop"] = require(game:GetService("ReplicatedStorage").TS.games.bedwars.shop["bedwars-shop"]).BedwarsShop,
	["ShopItems"] = debug.getupvalue(require(game:GetService("ReplicatedStorage").TS.games.bedwars.shop["bedwars-shop"]).BedwarsShop.getShopItem, 2),
	["ShopRight"] = require(lplr.PlayerScripts.TS.controllers.games.bedwars.shop.ui["item-shop"].right["shop-right"]).BedwarsItemShopRight,
	["SpawnRavenRemote"] = getremote(debug.getconstants(getmetatable(KnitClient.Controllers.RavenController).spawnRaven)),
	["SoundManager"] = (newupdate and require(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@easy-games"]["game-core"]).SoundManager or require(game:GetService("ReplicatedStorage").TS.sound["sound-manager"]).SoundManager),
	["SoundList"] = require(game:GetService("ReplicatedStorage").TS.sound["game-sound"]).GameSound,
	["sprintTable"] = KnitClient.Controllers.SprintController,
	["StopwatchController"] = KnitClient.Controllers.StopwatchController,
	["SwingSword"] = getmetatable(KnitClient.Controllers.SwordController).swingSwordAtMouse,
	["SwingSwordRegion"] = getmetatable(KnitClient.Controllers.SwordController).swingSwordInRegion,
	["SwordController"] = KnitClient.Controllers.SwordController,
	["TreeRemote"] = getremote(debug.getconstants(debug.getprotos(debug.getprotos(KnitClient.Controllers.BigmanController.KnitStart)[2])[1])),
	["TripleShotMeta"] = require(game:GetService("ReplicatedStorage").TS.kit["triple-shot"]["triple-shot"]).TripleShot,
	["VictoryScreen"] = require(lplr.PlayerScripts.TS.controllers["game"].match.ui["victory-section"]).VictorySection,
	["ViewmodelController"] = KnitClient.Controllers.ViewmodelController,
	["WeldTable"] = require(game:GetService("ReplicatedStorage").TS.util["weld-util"]).WeldUtil,
}

local function runcode(func)
	func()
end

local function makerandom(min, max)
	return Random.new().NextNumber(Random.new(), min, max)
end

local function getblock(pos)
	return bedwars["BlockEngine2"]:getStore():getBlockAt(bedwars["BlockEngine2"]:getBlockPosition(pos))
end

local function friendCheck(plr, recolor)
	return (recolor and GuiLibrary["ObjectsThatCanBeSaved"]["Recolor visualsToggle"]["Api"]["Enabled"] or (not recolor)) and GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["ObjectsThatCanBeSaved"]["FriendsListTextList"]["Api"]["ObjectList"], plr.Name)
end

local function getPlayerColor(plr)
	return (friendCheck(plr, true) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1) or tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color)
end

shared.vapeteamcheck = function(plr)
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] and bedwars["PlayerUtil"].getGamePlayer(lplr):getTeamId() ~= bedwars["PlayerUtil"].getGamePlayer(plr):getTeamId() or GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] == false)
end

local function targetCheck(plr, check)
	return (check and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("ForceField") == nil or check == false)
end

local function isAlive(plr)
	if plr then
		return plr and plr.Character and plr.Character.Parent ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid")
	end
	return lplr and lplr.Character and lplr.Character.Parent ~= nil and lplr.Character:FindFirstChild("HumanoidRootPart") and lplr.Character:FindFirstChild("Head") and lplr.Character:FindFirstChild("Humanoid")
end

local localentity = bedwars["getEntityTable"]["getLocalPlayerEntity"]()

local function switchItem(tool)
	lplr.Character.HandInvItem.Value = tool
	bedwars["ClientHandler"]:Get(bedwars["changeItem"]):CallServerAsync({
		hand = tool
	})
end

local function switchToAndUseTool(block, legit)
	local tool = nil
	local toolnum = 0
	local blockmeta = bedwars["getItemMetadata"](block.Name)
	local blockType = ""
	if blockmeta["block"] and blockmeta["block"]["breakType"] then
		blockType = blockmeta["block"]["breakType"]
	end
	for i,v in pairs(bedwars["getInventory"](lplr)["items"]) do
		local meta = bedwars["getItemMetadata"](v["itemType"])
		if meta["breakBlock"] and meta["breakBlock"][blockType] then
			tool = v
			break
		end
	end
	if tool and (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value ~= tool["tool"]) then
		if legit then
			bedwars["ClientStoreHandler"]:dispatch({
				type = "InventorySelectHotbarSlot", 
				slot = getHotbarSlot(tool["itemType"])
			})
		end
		switchItem(tool["tool"])
	end
end

local function getlastblock(pos, normal)
	local lastfound = nil
	for i = 1, 20 do
		local extrablock = getblock(pos + (Vector3.FromNormalId(normal) * (i * 3)))
		if extrablock and extrablock.Parent ~= nil then
			lastfound = extrablock
		else
			break
		end
	end
	return lastfound
end

local healthbarblocktable = {
	["blockHealth"] = -1,
	["breakingBlockPosition"] = Vector3.new(0, 0, 0)
}
bedwars["breakBlock"] = function(pos, effects, normal)
	local block = (getlastblock(pos, Enum.NormalId[normal]) or getblock(pos))
	local olditem = lplr.Character.HandInvItem.Value
	local blockhealthbarpos = {blockPosition = Vector3.new(0, 0, 0)}
	local blockdmg = 0
	if block and block.Parent ~= nil then
		switchToAndUseTool(block)
		blockhealthbarpos = {
			blockPosition = bedwars["BlockEngine2"]:getBlockPosition(block.Position)
		}
		if healthbarblocktable.blockHealth == -1 or blockhealthbarpos.blockPosition ~= healthbarblocktable.breakingBlockPosition then
			healthbarblocktable.blockHealth = block:GetAttribute("Health")
			healthbarblocktable.breakingBlockPosition = blockhealthbarpos.blockPosition
		end
		blockdmg = bedwars["BlockEngine2"]:calculateBlockDamage(lplr, blockhealthbarpos)
		healthbarblocktable.blockHealth = healthbarblocktable.blockHealth - blockdmg
		if healthbarblocktable.blockHealth < 0 then
			healthbarblocktable.blockHealth = 0
		end
		if effects then
			bedwars["BlockHealthbar"]["updateHealthbar"](bedwars["BlockHealthbar2"], blockhealthbarpos, healthbarblocktable.blockHealth, block:GetAttribute("MaxHealth"), blockdmg)
		end
		bedwars["ClientHandlerDamageBlock"]:Get("DamageBlock"):CallServerAsync({
			blockRef = blockhealthbarpos, 
			hitPosition = block.Position, 
			hitNormal = Vector3.FromNormalId(Enum.NormalId[normal])
		}):andThen(function(p9)
			if olditem then
				switchToAndUseTool(olditem)
			end
		end)
		if effects then
			if healthbarblocktable.blockHealth <= 0 then
				bedwars["BlockHealthbar2"].breakEffect:playBreak(block.Name, blockhealthbarpos.blockPosition, lplr)
				bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning()
			else
				bedwars["BlockHealthbar2"].breakEffect:playHit(block.Name, blockhealthbarpos.blockPosition, lplr)
			end
		end
	end
	wait(0.3)
end	

local function getEquipped()
	local type = ""
	local obj = (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value or nil)
	if obj then
		if obj.Name:find("sword") or obj.Name:find("blade") or obj.Name:find("baguette") then
			type = "sword"
		end
		if obj.Name:find("wool") then
			type = "block"
		end
		if obj.Name:find("bow") then
			type = "bow"
		end
	end
    return {["Object"] = obj, ["Type"] = type}
end

local function nakedcheck(plr)
	local inventory = bedwars["getInventory"](plr)
	return inventory["armor"][4] ~= nil and inventory["armor"][5] ~= nil and inventory["armor"][6] ~= nil
end

local function isPlayerTargetable(plr, target, friend, team)
    return plr ~= lplr and plr and isAlive(plr) and targetCheck(plr, target) and ((team and plr.Team == lplr.Team) or (team == nil and shared.vapeteamcheck(plr)))
end

local function vischeck(pos, pos2, ignore)
	local vistab = cam:GetPartsObscuringTarget({pos, pos2}, ignore)
	for i,v in pairs(vistab) do
		print(i,v:GetFullName())
	end
	return not unpack(vistab)
end

local function isJumping()
	if lplr.Character.Humanoid.Jump then
		return true
	else
		return false
	end
end

local function GetAllNearestHumanoidToPosition(distance, amount)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end

local function GetAllNearestHumanoidToPosition2(distance, amount, teamcheck)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if (teamcheck and (v ~= lplr and v.Character) or isPlayerTargetable(v, true, true)) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end


local function GetNearestHumanoidToPosition(distance)
	local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, false) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= closest then
                    closest = mag
                    returnedplayer = v
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToMouse(distance, checkvis)
    local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and (checkvis == false or checkvis and (vischeck(v.Character, "Head") or vischeck(v.Character, "HumanoidRootPart"))) then
                local vec, vis = cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                if vis then
                    local mag = (uis:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).magnitude
                    if mag <= closest then
                        closest = mag
                        returnedplayer = v
                    end
                end
            end
        end
    end
    return returnedplayer
end
local hitrealremote =  bedwars["ClientHandler"]:Get(getremote(debug.getconstants(shared.backup_attack)))["instance"]
function hitPlayer(plr)
	hitrealremote:InvokeServer({
		["weapon"] = getSword()["tool"],
		["entityInstance"] = plr.Character,
		["validate"] = {
			["raycast"] = {
				["cameraPosition"] = hashvec(cam.CFrame.p), 
				["cursorDirection"] = hashvec(Ray.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position).Unit.Direction)
			},
			["targetPosition"] = hashvec(plr.Character.HumanoidRootPart.Position),
			["selfPosition"] = hashvec(lplr.Character.HumanoidRootPart.Position)
		}
	})
end

local CinematicGui = {["Enabled"] = false}
function hideui(bool2)
	local bool = not bool2
	if CinematicGui["Enabled"] and bedwars["AppController"]:isAppOpen("BedwarsItemShopApp") or bedwars["AppController"]:isAppOpen("BedwarsTeamUpgradeApp") or (GuiLibrary["MainGui"]["ScaledGui"] and GuiLibrary["MainGui"]["ScaledGui"]["ClickGui"].Visible or GuiLibrary["MainGui"]["ClickGui"] and GuiLibrary["MainGui"]["ClickGui"].Visible) then
		game:GetService("UserInputService").MouseIconEnabled = true
	else
		game:GetService("UserInputService").MouseIconEnabled = bool
	end

	for i,v in pairs(game.CoreGui:GetChildren()) do
		if v.Name == "ThemeProvider" then
			v.Enabled = bool
		end
	end

	for i,v in pairs(game.Players.LocalPlayer.PlayerGui:GetChildren()) do
		if v.Name == "Chat" and v:IsA("ScreenGui") then
			v.Enabled = bool
		end
	end

	game.Players.LocalPlayer.PlayerGui.HudApp.Enabled = bool
	game.Players.LocalPlayer.PlayerGui.hotbar.Enabled = bool
	game.Players.LocalPlayer.PlayerGui.NotificationApp.Enabled = bool
end

Cinematic = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Cinematic", 
	["Function"] = function(callback)
		if callback then
			BindToRenderStep("Cinematic", 1, function()
				hideui(true)
			end)
		else
			UnbindFromRenderStep("Cinematic")
			hideui(false)
		end
	end,
	["HoverText"] = "Hides all uis that arent vape.\nUse for videos and screenshots."
})
CinematicGui = Cinematic.CreateToggle({
	["Name"] = "UI Mouse",
	["Function"] = function() end,
	["Default"] = true,
	["HoverText"] = "Shows the mouse in the shop & vape."
})


runcode(function()
	GuiLibrary["RemoveObject"]("HealthOptionsButton")

	local old = {["Enabled"] = false}

	local UserInfoUI = GuiLibrary.CreateCustomWindow({
		["Name"] = "UserInfoGUI", 
		["Icon"] = "vape/assets/TextGUIIcon1.png", 
		["IconSize"] = 21
	})
	UserInfoUI.SetVisible(false)
	UserInfoUI["Bypass"] = true

	local UserInfoFrame = Instance.new("Frame", UserInfoUI.GetCustomChildren())
	UserInfoFrame.Size = UDim2.new(0, 100, 0, 100)
	UserInfoFrame.Position = UDim2.new(0.5, 0, 0, 0)
	UserInfoFrame.AnchorPoint = Vector2.new(0.5, 0)
	UserInfoFrame.Transparency = 1
	UserInfoFrame.ZIndex = -1

	local UserInfoListLayout = Instance.new("UIListLayout", UserInfoFrame)

	local HealthText = Instance.new("TextLabel")
	HealthText.Font = Enum.Font.SourceSans
	HealthText.TextSize = 20
	HealthText.Text = "100 HP"
	HealthText.Position = UDim2.new(0.5, 0, 0.605, 0)
	HealthText.AnchorPoint = Vector2.new(0.5, 0.5)
	HealthText.BackgroundTransparency = 1
	HealthText.TextColor3 = Color3.fromHSV(1, 1, 1)
	HealthText.Size = UDim2.new(0, 100, 0, 20)
	HealthText.Visible = false
	HealthText.Parent = UserInfoFrame
	HealthText.TextStrokeColor3 = Color3.new(0,0,0)
	HealthText.TextStrokeTransparency = 0.1
	HealthText.ZIndex = -1
	
	local WoolText = Instance.new("TextLabel")
	WoolText.Font = Enum.Font.SourceSans
	WoolText.TextSize = 20
	WoolText.Text = "0 BLOCKS"
	WoolText.Position = UDim2.new(0.5, 0, 0.5, 90)
	WoolText.AnchorPoint = Vector2.new(0.5, 0.5)
	WoolText.BackgroundTransparency = 1
	WoolText.TextColor3 = Color3.fromHSV(1, 1, 1)
	WoolText.Size = UDim2.new(0, 100, 0, 20)
	WoolText.Visible = false
	WoolText.Parent = UserInfoFrame
	WoolText.TextStrokeColor3 = Color3.new(0,0,0)
	WoolText.TextStrokeTransparency = 0.1
	WoolText.ZIndex = -1
	
	local EmerText = Instance.new("TextLabel")
	EmerText.Font = Enum.Font.SourceSans
	EmerText.TextSize = 20
	EmerText.Text = "0 EMERALD"
	EmerText.Position = UDim2.new(0.5, 0, 0.5, 0)
	EmerText.AnchorPoint = Vector2.new(0.5, 0.5)
	EmerText.BackgroundTransparency = 1
	EmerText.TextColor3 = Color3.fromHSV(1, 1, 1)
	EmerText.Size = UDim2.new(0, 100, 0, 20)
	EmerText.Visible = false
	EmerText.Parent = UserInfoFrame
	EmerText.TextStrokeColor3 = Color3.new(0,0,0)
	EmerText.TextStrokeTransparency = 0.1
	EmerText.ZIndex = -1

	local DiamText = Instance.new("TextLabel")
	DiamText.Font = Enum.Font.SourceSans
	DiamText.TextSize = 20
	DiamText.Text = "0 DIAMOND"
	DiamText.Position = UDim2.new(0.5, 0, 0.5, 0)
	DiamText.AnchorPoint = Vector2.new(0.5, 0.5)
	DiamText.BackgroundTransparency = 1
	DiamText.TextColor3 = Color3.fromHSV(1, 1, 1)
	DiamText.Size = UDim2.new(0, 100, 0, 20)
	DiamText.Visible = false
	DiamText.Parent = UserInfoFrame
	DiamText.TextStrokeColor3 = Color3.new(0,0,0)
	DiamText.TextStrokeTransparency = 0.1
	DiamText.ZIndex = -1

	local IronText = Instance.new("TextLabel")
	IronText.Font = Enum.Font.SourceSans
	IronText.TextSize = 20
	IronText.Text = "0 IRON"
	IronText.Position = UDim2.new(0.5, 0, 0.5, 0)
	IronText.AnchorPoint = Vector2.new(0.5, 0.5)
	IronText.BackgroundTransparency = 1
	IronText.TextColor3 = Color3.fromHSV(1, 1, 1)
	IronText.Size = UDim2.new(0, 100, 0, 20)
	IronText.Visible = false
	IronText.Parent = UserInfoFrame
	IronText.TextStrokeColor3 = Color3.new(0,0,0)
	IronText.TextStrokeTransparency = 0.1
	IronText.ZIndex = -1

	local uiinfo = {["Enabled"] = false}
	local uiinfoiron = {["Enabled"] = false}
	local uiinfowool = {["Enabled"] = false}
	local uiinfohealth = {["Enabled"] = false}
	local uiinfodiam = {["Enabled"] = false}
	local uiinfoemer = {["Enabled"] = false}
	local uiinfo = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
		["Name"] = "UserInfo", 
		["Function"] = function(callback)
			UserInfoUI.SetVisible(callback)
			if old["Enabled"] then 
				UserInfoUI.SetVisible(false)
			end
			if callback then
				EmerText.Visible = uiinfoemer["Enabled"]
				DiamText.Visible = uiinfodiam["Enabled"]
				IronText.Visible = uiinfoiron["Enabled"]
				HealthText.Visible = uiinfohealth["Enabled"]
				WoolText.Visible = uiinfowool["Enabled"]
				BindToRenderStep("uinfo", 1, function()
					if isAlive() then
						if uiinfoiron["Enabled"] then
							local ironamt = getmineralamount("iron")
							if ironamt == nil then 
								IronText.Text = "0 IRON"
							else
								IronText.Text = tostring(ironamt).." IRON"
							end
						else
							IronText.Visible = false
						end

						if uiinfodiam["Enabled"] then
							local diamamt = getmineralamount("diamond")
							if diamamt == nil then 
								DiamText.Text = "0 DIAMOND"
							else
								DiamText.Text = tostring(diamamt).." DIAMOND"
							end
						else
							DiamText.Visible = false
						end

						if uiinfoemer["Enabled"] then
							local amt = getmineralamount("emerald")
							if amt == nil then 
								EmerText.Text = "0 EMERALD"
							else
								EmerText.Text = tostring(amt).." EMERALD"
							end
						else
							EmerText.Visible = false
						end

						if uiinfowool["Enabled"] then
							local wool, woolamt = getwool()
							if woolamt == nil then
								WoolText.Text = "0 BLOCKS"
							else
								WoolText.Text = tostring(woolamt).." BLOCKS"
							end
						else
							WoolText.Visible = false
						end

						if uiinfohealth["Enabled"] then
							HealthText.Text = tostring(math.round(lplr.Character.Humanoid.Health)).." HP"
						else
							HealthText.Visible = false
						end
					end
				end)
			else
				IronText.Visible = false
				HealthText.Visible = false
				WoolText.Visible = false
				EmerText.Visible = false
				DiamText.Visible = false
				UnbindFromRenderStep("uinfo")
			end
		end,
		["HoverText"] = "Displays health & wool in the center of your screen."
	})


	local uiinfohealth = uiinfo.CreateToggle({
		["Name"] = "HP",
		["Function"] = function(callback)
			HealthText.Visible = callback
			uiinfohealth["Enabled"] = callback
			if uiinfo["Enabled"] and isAlive() and callback then 
				HealthText.Visible = true
			else
				HealthText.Visible = false
			end
		end,
		["Default"] = true
	})
	local uiinfowool = uiinfo.CreateToggle({
		["Name"] = "Blocks",
		["Function"] = function(callback)
			WoolText.Visible = callback
			uiinfowool["Enabled"] = callback
			if uiinfo["Enabled"] and isAlive() and callback then 
				WoolText.Visible = true
			else
				WoolText.Visible = false
			end
		end,
		["Default"] = true
	})

	local uiinfoemer = uiinfo.CreateToggle({
		["Name"] = "Emerald",
		["Function"] = function(callback)
			EmerText.Visible = callback
			uiinfoemer["Enabled"] = callback
			if uiinfo["Enabled"] and isAlive() and callback then 
				EmerText.Visible = true
			else
				EmerText.Visible = false
			end
		end,
		["Default"] = true
	})

	local uiinfodiam = uiinfo.CreateToggle({
		["Name"] = "Diamond",
		["Function"] = function(callback)
			DiamText.Visible = callback
			uiinfodiam["Enabled"] = callback
			if uiinfo["Enabled"] and isAlive() and callback then 
				DiamText.Visible = true
			else
				DiamText.Visible = false
			end
		end,
		["Default"] = true
	})

	local uiinfoiron = uiinfo.CreateToggle({
		["Name"] = "Iron",
		["Function"] = function(callback)
			IronText.Visible = callback
			uiinfoiron["Enabled"] = callback
			if uiinfo["Enabled"] and isAlive() and callback then 
				IronText.Visible = true
			else
				IronText.Visible = false
			end
		end,
		["Default"] = true
	})

	local Color = uiinfo.CreateColorSlider({
		["Name"] = "Color",
		["Function"] = function(hue, saturation, value)
			saturation = saturation or 0.8
			value = value or 0.8
			IronText.TextColor3 = Color3.fromHSV(hue, saturation, value)
			EmerText.TextColor3 = Color3.fromHSV(hue, saturation, value)
			DiamText.TextColor3 = Color3.fromHSV(hue, saturation, value)
			WoolText.TextColor3 = Color3.fromHSV(hue, saturation, value)
			HealthText.TextColor3 = Color3.fromHSV(hue, saturation, value)
		end
	})

	old = uiinfo.CreateToggle({
		["Name"] = "Center",
		["Function"] = function(callback) 
			UserInfoUI.SetVisible(not callback)
			if (callback) then 
				UserInfoFrame.Parent = GuiLibrary["MainGui"]
				UserInfoFrame.Position = UDim2.new(0.5, 0, 0.525, 0)
			else
				UserInfoFrame.Parent = UserInfoUI.GetCustomChildren()
				UserInfoFrame.Position = UDim2.new(0.5, 0, 0, 0)
			end
		end,
		["HoverText"] = "Centers the UserInfoUI",
		["Default"] = false,
	})
end)

local bedphrases = {"some retard broke ur bed", "yolo", "going bedless", "u only need 1 life right?", "1 life is enough", "watch out, 1 life left","go get em"}
local killphrases = {"L to","assassinated","destroyed","rip","annihilated","obliterated","killed","get down","death successfully","skill issue","L noobie","gg ez","u mad","get sh*t on","garbage","get ez'ed","finessed"}
local notifications = {["Enabled"] = false}

bedwars["ClientHandler"]:WaitFor("BedwarsBedBreak"):andThen(function(p13)
	p13:Connect(function(p14)
		if notifications["Enabled"] then
			local team = p14.brokenBedTeam.displayName
			if team == lplr.Team.Name then
				createnotification("Bed broken!", bedphrases[math.random(1, #bedphrases)], 2)
			end
		end
	end)
end)

bedwars["ClientHandler"]:WaitFor("EntityDeathEvent"):andThen(function(p6)
	p6:Connect(function(p7)
		if notifications["Enabled"] then
			if p7.fromEntity and p7.fromEntity == lplr.Character then
				local plr = players:GetPlayerFromCharacter(p7.entityInstance)
				createnotification("Killed "..plr.Name, killphrases[math.random(1, #killphrases)].." "..plr.Name, 2)
			end
		end
	end)
end)


local notifications = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Notifications",
	["Function"]= function(callback) notifications["Enabled"] = callback end,
	["HoverText"] = "Sends you a notification when certain actions happen"
})

local shadows = {["Enabled"] = false}
local softshadows = {["Enabled"] = false}
local technology = Enum.Technology.ShadowMap

function hiddenprop()
	local suc, err = pcall(function()
		gethiddenproperty(game.Lighting, "Technology")
	end)

	if suc then
		return true
	else
		return false
	end
end

getgenv().oldLightingProp = {
	Ambient = lighting.Ambient,
	Brightness = lighting.Brightness,
	ColorShift_Bottom = lighting.ColorShift_Bottom,
	ColorShift_Top = lighting.ColorShift_Top,
	GlobalShadows = lighting.GlobalShadows,
	OutdoorAmbient = lighting.OutdoorAmbient,
	ShadowSoftness = lighting.ShadowSoftness,
	EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale,
	EnvironmentSpecularScale = lighting.EnvironmentSpecularScale,
	ClockTime = lighting.ClockTime,
	GeographicLatitude = lighting.GeographicLatitude,
}
getgenv().oldLighting = {}
for i,v in pairs(lighting:GetChildren()) do 
	if not v:IsA("BlurEffect") and v.ClassName:lower():find("effect") then 
		getgenv().oldLighting[v.Name] = v
	end 
	if hiddenprop() then
		getgenv().oldLighting["Technology"] = gethiddenproperty(lighting, "Technology")
	end
end

function revertshaders()
	for i,v in pairs(getgenv().oldLightingProp) do
		lighting[i] = v
	end
	for i,v in pairs(lighting:GetChildren()) do 
		if not v:IsA("BlurEffect") and v.ClassName:lower():find("effect") then 
			pcall(function()
				v.Parent = nil
			end)
		end 
	end
	for i,v in pairs(oldLighting) do 
		pcall(function()
			v.Parent = lighting
		end)
	end
	for i,v in pairs(getgenv().shaders) do 
		pcall(function()
			v.Parent = nil
		end)
	end
	if hiddenprop() then
		sethiddenproperty(lighting, "Technology", getgenv().oldLighting["Technology"])
	end
end

function doshaders()
	getgenv().shaders = {}
	for i,v in pairs(lighting:GetChildren()) do 
		if not v:IsA("BlurEffect") and v.ClassName:lower():find("effect") then 
			v.Parent = nil
		end 
	end
		local Bloom = lighting:FindFirstChild("EngoShaders_Bloom") or Instance.new("BloomEffect", lighting)
		local ColorCorrection = lighting:FindFirstChild("EngoShaders_ColorCorrection") or Instance.new("ColorCorrectionEffect", lighting)
		getgenv().shaders["Bloom"] = Bloom 
		getgenv().shaders["ColorCorrection"] = ColorCorrection
		lighting.Ambient = Color3.fromRGB(230, 164, 50)
		lighting.Brightness = 7
		lighting.ColorShift_Bottom = Color3.fromRGB(0,0,0)
		lighting.ColorShift_Top = Color3.fromRGB(217, 140, 32)
		lighting.GlobalShadows = shadows["Enabled"]
		lighting.OutdoorAmbient = Color3.fromRGB(102, 105, 50)
		lighting.ShadowSoftness =  softshadows["Enabled"] and 1 or 0
		lighting.EnvironmentDiffuseScale = 0.05
		lighting.EnvironmentSpecularScale = 0.05
		if hiddenprop() then
			sethiddenproperty(lighting, "Technology", technology)
		end
		lighting.ClockTime = 9
		lighting.GeographicLatitude = 80
		Bloom.Name = "EngoShaders_Bloom"
		Bloom.Intensity = 0.1 
		Bloom.Size = 46
		Bloom.Threshold = 0.8
		ColorCorrection.Name = "EngoShaders_ColorCorrection"
		ColorCorrection.TintColor = Color3.fromRGB(244, 255, 210)
		ColorCorrection.Contrast = 0.2
		ColorCorrection.Brightness = -0.05
	end

shaders = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Shaders",
	["Function"] = function(callback) 
		if callback then
			doshaders()
		else
			revertshaders()
		end
	end,
	["HoverText"] = "Makes the game look so much nicer",
})

shadowst = shaders.CreateToggle({
	["Name"] = "Shadows",
	["Function"] = function(callback)
		if shaders["Enabled"] then
			lighting.GlobalShadows = callback
		end
		shadows["Enabled"] = callback
	end,
	["HoverText"] = "Enable shadows",
})

softshadowst = shaders.CreateToggle({
	["Name"] = "SoftShadows",
	["Function"] = function(callback) 
		if shaders["Enabled"] then
			lighting.ShadowSoftness = callback and 1 or 0
		end
		softshadows["Enabled"] = callback
	end,
	["HoverText"] = "Softer Shadows",
})
if hiddenprop() then
	technologyt = shaders.CreateDropdown({
		["Name"] = "Tech",
		["List"] = {"ShadowMap", "Future", "Voxel", "Compatibility"},
		["Function"] = function(arg)
			technology = arg == "ShadowMap" and Enum.Technology.ShadowMap or arg == "Future" and Enum.Technology.Future or arg == "Voxel" and Enum.Technology.Voxel or arg == "Compatibility" and Enum.Technology.Compatibility or Enum.Technology.ShadowMap
			if shaders["Enabled"] then
				sethiddenproperty(lighting, "Technology", technology)
			end
		end,
	})
end
